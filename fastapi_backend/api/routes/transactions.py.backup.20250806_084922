"""
Transaction management routes - With Entity-Wide Access Control
Updated to allow viewers and traders to access all transaction data within their entity
Traders can also create transactions for any user within their entity
"""

from fastapi import APIRouter, HTTPException, Depends
from typing import Optional
from api.dependencies import get_database
from api.database import DatabaseManager
from api.updated_auth_dependencies import (
    require_entity_any_access,
    require_entity_trader_access,
    EntityAuthenticatedUser,
    get_user_accessible_entity_filter
)
import logging

logger = logging.getLogger(__name__)
router = APIRouter()


@router.get("/user/{username}")
async def get_user_transactions(
    username: str,
    current_user: EntityAuthenticatedUser = Depends(require_entity_any_access()),
    limit: int = 50,
    offset: int = 0,
    transaction_type: Optional[str] = None,
    status: Optional[str] = None,
    db: DatabaseManager = Depends(get_database)
):
    """
    Get transactions for a user within the current user's accessible entities.

    Both viewers and traders can access transaction data for any user within their entity.
    Admins can access transaction data for any user across all entities.
    """
    try:
        # First verify the target user exists and is active
        if db.db_type == 'postgresql':
            user_query = "SELECT id, entity_id FROM users WHERE username = %s AND is_active = %s"
            user_params = (username, True)
        else:
            user_query = "SELECT id, entity_id FROM users WHERE username = ? AND is_active = ?"
            user_params = (username, 1)

        user_results = db.execute_query(user_query, user_params)

        if not user_results:
            raise HTTPException(
                status_code=404,
                detail=f"User '{username}' not found or inactive"
            )

        target_user = user_results[0]
        user_id = target_user['id']
        target_entity_id = target_user.get('entity_id')

        # For non-admin users, verify the target user is within their accessible entities
        if current_user.role.value != 'admin':
            if not target_entity_id or not current_user.has_entity_access(target_entity_id):
                raise HTTPException(
                    status_code=403,
                    detail=f"Access denied. User '{username}' is not within your accessible entities"
                )

        # Build transactions query with entity filtering
        if db.db_type == 'postgresql':
            query = """
                SELECT t.id, t.transaction_type, t.status, t.amount, t.currency_code,
                       t.balance_before, t.balance_after, t.description, t.external_reference,
                       t.created_at, t.processed_at, t.fee_amount, t.fee_currency_code,
                       u.entity_id, c.name as currency_name, c.symbol as currency_symbol
                FROM transactions t
                JOIN users u ON t.user_id = u.id
                JOIN currencies c ON t.currency_code = c.code
                WHERE t.user_id = %s
            """
            params = [user_id]

            if transaction_type:
                query += " AND t.transaction_type = %s"
                params.append(transaction_type)

            if status:
                query += " AND t.status = %s"
                params.append(status)

            query += " ORDER BY t.created_at DESC LIMIT %s OFFSET %s"
            params.extend([limit, offset])
        else:
            # SQLite
            query = """
                SELECT t.id, t.transaction_type, t.status, t.amount, t.currency_code,
                       t.balance_before, t.balance_after, t.description, t.external_reference,
                       t.created_at, t.processed_at, t.fee_amount, t.fee_currency_code,
                       u.entity_id, c.name as currency_name, c.symbol as currency_symbol
                FROM transactions t
                JOIN users u ON t.user_id = u.id
                JOIN currencies c ON t.currency_code = c.code
                WHERE t.user_id = ?
            """
            params = [user_id]

            if transaction_type:
                query += " AND t.transaction_type = ?"
                params.append(transaction_type)

            if status:
                query += " AND t.status = ?"
                params.append(status)

            query += " ORDER BY t.created_at DESC LIMIT ? OFFSET ?"
            params.extend([limit, offset])

        # Add entity filtering for non-admin users
        if current_user.role.value != 'admin':
            entity_filter, entity_params = await get_user_accessible_entity_filter(
                current_user, db, "u"
            )
            if entity_filter:
                # Insert entity filter before ORDER BY
                order_pos = query.rfind("ORDER BY")
                if order_pos > 0:
                    query = query[:order_pos] + f"AND {entity_filter} " + query[order_pos:]
                    # Insert entity params before limit/offset params
                    params = params[:-2] + entity_params + params[-2:]

        transactions = db.execute_query(query, params)

        logger.info(
            f"User {current_user.username} (role: {current_user.role.value}) "
            f"accessed {len(transactions)} transactions for user {username} in entity {target_entity_id}"
        )

        return {
            "success": True,
            "data": transactions,
            "user": username,
            "entity_id": target_entity_id,
            "pagination": {
                "limit": limit,
                "offset": offset,
                "count": len(transactions)
            },
            "access_info": {
                "viewer_role": current_user.role.value,
                "entity_access": "admin" if current_user.role.value == 'admin' else "entity_member"
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error retrieving transactions for user {username}: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Error retrieving transactions: {str(e)}"
        )


@router.get("/")
async def get_entity_transactions_summary(
    current_user: EntityAuthenticatedUser = Depends(require_entity_any_access()),
    limit: int = 100,
    offset: int = 0,
    transaction_type: Optional[str] = None,
    status: Optional[str] = None,
    currency_code: Optional[str] = None,
    db: DatabaseManager = Depends(get_database)
):
    """
    Get transaction summary for all users within the current user's accessible entities.

    This endpoint allows viewers and traders to see transaction data
    for their entire entity.
    """
    try:
        # Build entity-filtered transactions query
        if db.db_type == 'postgresql':
            query = """
                SELECT
                    t.id, t.transaction_type, t.status, t.amount, t.currency_code,
                    t.balance_before, t.balance_after, t.description, t.created_at, t.processed_at,
                    u.username, u.entity_id, e.name as entity_name,
                    c.name as currency_name, c.symbol as currency_symbol
                FROM transactions t
                JOIN users u ON t.user_id = u.id
                JOIN entities e ON u.entity_id = e.id
                JOIN currencies c ON t.currency_code = c.code
                WHERE u.is_active = %s
            """
            params = [True]

            if transaction_type:
                query += " AND t.transaction_type = %s"
                params.append(transaction_type)

            if status:
                query += " AND t.status = %s"
                params.append(status)

            if currency_code:
                query += " AND t.currency_code = %s"
                params.append(currency_code.upper())
        else:
            # SQLite
            query = """
                SELECT
                    t.id, t.transaction_type, t.status, t.amount, t.currency_code,
                    t.balance_before, t.balance_after, t.description, t.created_at, t.processed_at,
                    u.username, u.entity_id, e.name as entity_name,
                    c.name as currency_name, c.symbol as currency_symbol
                FROM transactions t
                JOIN users u ON t.user_id = u.id
                JOIN entities e ON u.entity_id = e.id
                JOIN currencies c ON t.currency_code = c.code
                WHERE u.is_active = ?
            """
            params = [1]

            if transaction_type:
                query += " AND t.transaction_type = ?"
                params.append(transaction_type)

            if status:
                query += " AND t.status = ?"
                params.append(status)

            if currency_code:
                query += " AND t.currency_code = ?"
                params.append(currency_code.upper())

        # Add entity filtering for non-admin users
        if current_user.role.value != 'admin':
            entity_filter, entity_params = await get_user_accessible_entity_filter(
                current_user, db, "u"
            )
            if entity_filter:
                query += f" AND {entity_filter}"
                params.extend(entity_params)

        query += " ORDER BY t.created_at DESC LIMIT ? OFFSET ?"
        params.extend([limit, offset])

        transactions = db.execute_query(query, params)

        # Group transactions by entity
        entity_transactions = {}
        for transaction in transactions:
            entity_id = transaction['entity_id']

            if entity_id not in entity_transactions:
                entity_transactions[entity_id] = {
                    'entity_id': entity_id,
                    'entity_name': transaction['entity_name'],
                    'transactions': [],
                    'total_transactions': 0
                }

            entity_transactions[entity_id]['transactions'].append({
                'id': transaction['id'],
                'transaction_type': transaction['transaction_type'],
                'status': transaction['status'],
                'amount': transaction['amount'],
                'currency_code': transaction['currency_code'],
                'currency_name': transaction['currency_name'],
                'currency_symbol': transaction['currency_symbol'],
                'balance_before': transaction['balance_before'],
                'balance_after': transaction['balance_after'],
                'description': transaction['description'],
                'username': transaction['username'],
                'created_at': transaction['created_at'],
                'processed_at': transaction['processed_at']
            })
            entity_transactions[entity_id]['total_transactions'] += 1

        logger.info(
            f"User {current_user.username} (role: {current_user.role.value}) "
            f"accessed entity transaction summary"
        )

        return {
            "success": True,
            "data": list(entity_transactions.values()),
            "total_entities": len(entity_transactions),
            "pagination": {
                "limit": limit,
                "offset": offset,
                "count": len(transactions)
            },
            "access_info": {
                "viewer_role": current_user.role.value,
                "accessible_entities": current_user.accessible_entities,
                "entity_access": "admin" if current_user.role.value == 'admin' else "entity_member"
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error retrieving entity transaction summary: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Error retrieving entity transaction summary: {str(e)}"
        )


@router.post("/deposit")
async def create_deposit(
    deposit_data: dict,
    current_user: EntityAuthenticatedUser = Depends(require_entity_trader_access()),
    db: DatabaseManager = Depends(get_database)
):
    """
    Create a deposit transaction.

    Only traders (and admins) can create deposits.
    Traders can create deposits for any user within their entity.
    """
    try:
        username = deposit_data.get('username')
        amount = deposit_data.get('amount')
        currency_code = deposit_data.get('currency_code')
        description = deposit_data.get('description', 'Deposit transaction')

        if not all([username, amount, currency_code]):
            raise HTTPException(
                status_code=400,
                detail="Missing required fields: username, amount, currency_code"
            )

        # Verify the target user exists and is within accessible entities
        if db.db_type == 'postgresql':
            user_query = "SELECT id, entity_id FROM users WHERE username = %s AND is_active = %s"
            user_params = (username, True)
        else:
            user_query = "SELECT id, entity_id FROM users WHERE username = ? AND is_active = ?"
            user_params = (username, 1)

        user_results = db.execute_query(user_query, user_params)

        if not user_results:
            raise HTTPException(
                status_code=404,
                detail=f"User '{username}' not found or inactive"
            )

        target_user = user_results[0]
        user_id = target_user['id']
        target_entity_id = target_user.get('entity_id')

        # For non-admin users, verify the target user is within their accessible entities
        if current_user.role.value != 'admin':
            if not target_entity_id or not current_user.has_entity_access(target_entity_id):
                raise HTTPException(
                    status_code=403,
                    detail=f"Access denied. Cannot create deposit for user '{username}' outside your entity"
                )

        # Validate amount
        try:
            amount = float(amount)
            if amount <= 0:
                raise ValueError("Amount must be positive")
        except (ValueError, TypeError):
            raise HTTPException(
                status_code=400,
                detail="Invalid amount value"
            )

        # Create transaction ID
        import uuid
        transaction_id = str(uuid.uuid4())

        # Insert transaction (simplified - in production, you'd have more complex logic)
        if db.db_type == 'postgresql':
            insert_query = """
                INSERT INTO transactions (id, user_id, transaction_type, status, amount, currency_code,
                                        description, created_at, processed_at)
                VALUES (%s, %s, %s, %s, %s, %s, %s, NOW(), NOW())
            """
            params = (transaction_id, user_id, 'deposit', 'completed', amount, currency_code.upper(), description)
        else:
            insert_query = """
                INSERT INTO transactions (id, user_id, transaction_type, status, amount, currency_code,
                                        description, created_at, processed_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
            """
            params = (transaction_id, user_id, 'deposit', 'completed', amount, currency_code.upper(), description)

        db.execute_query(insert_query, params)

        logger.info(
            f"User {current_user.username} (role: {current_user.role.value}) "
            f"created deposit {transaction_id} for user {username} in entity {target_entity_id}"
        )

        return {
            "success": True,
            "message": f"Deposit of {amount} {currency_code.upper()} created successfully",
            "transaction_id": transaction_id,
            "user": username,
            "entity_id": target_entity_id,
            "access_info": {
                "created_by": current_user.username,
                "creator_role": current_user.role.value,
                "entity_access": "admin" if current_user.role.value == 'admin' else "entity_trader"
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error creating deposit: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Error creating deposit: {str(e)}"
        )


@router.post("/withdraw")
async def create_withdrawal(
    withdrawal_data: dict,
    current_user: EntityAuthenticatedUser = Depends(require_entity_trader_access()),
    db: DatabaseManager = Depends(get_database)
):
    """
    Create a withdrawal transaction.

    Only traders (and admins) can create withdrawals.
    Traders can create withdrawals for any user within their entity.
    """
    try:
        username = withdrawal_data.get('username')
        amount = withdrawal_data.get('amount')
        currency_code = withdrawal_data.get('currency_code')
        description = withdrawal_data.get('description', 'Withdrawal transaction')

        if not all([username, amount, currency_code]):
            raise HTTPException(
                status_code=400,
                detail="Missing required fields: username, amount, currency_code"
            )

        # Verify the target user exists and is within accessible entities
        if db.db_type == 'postgresql':
            user_query = "SELECT id, entity_id FROM users WHERE username = %s AND is_active = %s"
            user_params = (username, True)
        else:
            user_query = "SELECT id, entity_id FROM users WHERE username = ? AND is_active = ?"
            user_params = (username, 1)

        user_results = db.execute_query(user_query, user_params)

        if not user_results:
            raise HTTPException(
                status_code=404,
                detail=f"User '{username}' not found or inactive"
            )

        target_user = user_results[0]
        user_id = target_user['id']
        target_entity_id = target_user.get('entity_id')

        # For non-admin users, verify the target user is within their accessible entities
        if current_user.role.value != 'admin':
            if not target_entity_id or not current_user.has_entity_access(target_entity_id):
                raise HTTPException(
                    status_code=403,
                    detail=f"Access denied. Cannot create withdrawal for user '{username}' outside your entity"
                )

        # Validate amount
        try:
            amount = float(amount)
            if amount <= 0:
                raise ValueError("Amount must be positive")
        except (ValueError, TypeError):
            raise HTTPException(
                status_code=400,
                detail="Invalid amount value"
            )

        # Create transaction ID
        import uuid
        transaction_id = str(uuid.uuid4())

        # Insert transaction (simplified - in production, you'd check balances, etc.)
        if db.db_type == 'postgresql':
            insert_query = """
                INSERT INTO transactions (id, user_id, transaction_type, status, amount, currency_code,
                                        description, created_at, processed_at)
                VALUES (%s, %s, %s, %s, %s, %s, %s, NOW(), NOW())
            """
            params = (transaction_id, user_id, 'withdrawal', 'completed', amount, currency_code.upper(), description)
        else:
            insert_query = """
                INSERT INTO transactions (id, user_id, transaction_type, status, amount, currency_code,
                                        description, created_at, processed_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
            """
            params = (transaction_id, user_id, 'withdrawal', 'completed', amount, currency_code.upper(), description)

        db.execute_query(insert_query, params)

        logger.info(
            f"User {current_user.username} (role: {current_user.role.value}) "
            f"created withdrawal {transaction_id} for user {username} in entity {target_entity_id}"
        )

        return {
            "success": True,
            "message": f"Withdrawal of {amount} {currency_code.upper()} created successfully",
            "transaction_id": transaction_id,
            "user": username,
            "entity_id": target_entity_id,
            "access_info": {
                "created_by": current_user.username,
                "creator_role": current_user.role.value,
                "entity_access": "admin" if current_user.role.value == 'admin' else "entity_trader"
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error creating withdrawal: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Error creating withdrawal: {str(e)}"
        )
